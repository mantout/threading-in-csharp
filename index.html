<!DOCTYPE html>
<html>
<meta charset="utf-8"/>
<head>
<title>C#中的线程</title>
<link rel="stylesheet" type="text/css" href="./css/tstyles.css">
<link rel="stylesheet" type="text/css" media="print" href="./css/print.css">
<link type="text/css" rel="stylesheet" href="./css/sh_style.css">
<script type="text/javascript" src="./scripts/sh_main.min.js"></script>
<script type="text/javascript" src="./scripts/sh_csharp.js"></script>
<style type="text/css"></style>
</head>
<body onload="sh_highlightDocument();">
<div id="main">
  <p class="title">C#中的线程</p>
  <p class="author">作者：Joseph Albahari</p>
  <p class="author">翻译：<a href="http://www.chuwentao.com">chuwentao</a></p>
  <div id="ctl00_toc">
  <table class="toc" border="0" cellspacing="0" cellpadding="0">
	<tbody><tr>
	  <th class="tocactive">Part 1</th>
	  <th class="toc"><a class="toc" href="part2.html"> Part 2</a></th>
	  <th class="toc"><a class="toc" href="part3.html"> Part 3</a></th>
	  <th class="toc"><a class="toc" href="part4.html"> Part 4</a></th>
	  <th class="toc"><a class="toc" href="part5.html"> Part 5</a></th>
	</tr><tr>
	  <td class="tocactive">入门</td>
	  <td class="toc"><a class="toc" href="part2.html">线程同步基础</a></td>
	  <td class="toc"><a class="toc" href="part3.html">使用多线程</a></td>
	  <td class="toc"><a class="toc" href="part4.html">高级话题</a></td>
	  <td class="toc"><a class="toc" href="part5.html">并行编程</a></td>
	</tr></tbody>
  </table>
  </div>
  <p class="sectiontitle">Part 1: 入门</p>
  <h1><a name="_Introduction">Introduction and Concepts | 简介及概念</a></h1>
  <p>C# supports parallel execution of code through multithreading. A thread is an independent 
execution path, able to run simultaneously with other threads.</p>
  <p>C# 是通过多线程来支持代码的并行执行。一个线程就是一条独立的执行路径，可以与其他线程同时运行。</p>
  <p>A C# <em>client</em> program (Console, WPF, or Windows
Forms) starts in a single thread created automatically by the CLR and operating
system (the “main” thread), and is made multithreaded by creating additional
threads. Here’s a simple example and its output:</p>
  <p>C# <em>客户端程序</em>(Console, WPF, 或者 Windows Forms)的启动是从一个由公共运行库(CLR)和操作系统(OS)创建的线程(主线程)开始的，应用程序创建其他线程后就变成一个多线程程序。下面是一个示例及其输出：</p>
<div class="note">
	<p>All examples assume the following namespaces are imported:</p>
	<p>所有示例假定引入以下命名空间：</p>
	<pre>using System;
using System.Threading;</pre>

</div>

<pre class="sh_csharp">
class ThreadTest
{
  static void Main()
  {
    Thread t = new Thread (WriteY);          // Kick off a new thread | 创建一个新线程
    t.Start();                               // running WriteY() | 运行WriteY()
 
    // Simultaneously, do something on the main thread.
    // 同时，在主线程中也做同样的事情。
    for (int i = 0; i &lt; 1000; i++) Console.Write ("x");
  }
 
  static void WriteY()
  {
    for (int i = 0; i &lt; 1000; i++) Console.Write ("y");
  }
}
</pre>

<pre class="output">
xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
...
</pre>

<p>The main thread creates a new thread <code>t</code>
on which it runs a method that repeatedly prints the character “y”.
Simultaneously, the main thread repeatedly prints the character “x”:</p>
<p>主线程创建了一个新的线程 <code>t</code> ，线程 <code>t</code> 重复地打印字符’y’，同时，主线程也在重复地打印字符’x’：</p>
<div class="figure">
	<img width="700" height="179" src="./resources/NewThread.png" alt="Starting a new Thread" />
</div>

<p>Once started, a thread’s <code>IsAlive</code>
property returns <code>true</code>, until the point where the
thread ends. A thread ends when the delegate passed to the <code>Thread</code>’s
constructor finishes executing. Once ended, a thread cannot restart.</p>
<p>线程启动后，它的 <code>IsAlive</code> 属性就为 <code>true</code>，直到线程终止。构造线程时传入的代理运行完成后，线程就自动终止。终止了的线程无法再次启动。</p>
<p>The CLR assigns each thread its own memory stack so that
local variables are kept separate. In the next example, we define a method with
a local variable, then call the method simultaneously on the main thread and a
newly created thread:</p>
<p>公共运行库(CLR)为每一个线程分配用于存储局部变量的独立的栈空间。接下来的示例中，我们定义了一个方法，方法中定义了一个局部变量，然后在主线程和新建的线程中同时调用这个方法：</p>
<pre class="sh_csharp">
static void Main() 
{
  new Thread (Go).Start();      // Call Go() on a new thread | 在新建线程中调用 Go()
  Go();                         // Call Go() on the main thread | 在主线程中调用 Go()
}
 
static void Go()
{
  // Declare and use a local variable - 'cycles'
  // 声明并使用局部变量 'cycles'
  for (int cycles = 0; cycles &lt; 5; cycles++) Console.Write ('?');
}
</pre>

<pre class="output">
??????????
</pre>

<p>A separate copy of the cycles variable is created on each
thread's memory stack, and so the output is, predictably, ten question marks.</p>
<p>局部变量 <code>cycles</code> 在每个线程的栈中都是单独存储的，因此，程序的输出不出意料是10个问号。（译注：意思是说循环变量不会相互干扰。）</p>
<p>Threads share data if they have a common reference to the
same object instance. For example:</p>
<p>多个线程持有同一个对象的引用的话，他们就可以共享数据。例如：</p>

<pre class="sh_csharp">
class ThreadTest
{
  bool done;
 
  static void Main()
  {
    ThreadTest tt = new ThreadTest();   // Create a common instance | 创建一个共用的实例
    new Thread (tt.Go).Start();
    tt.Go();
  }
 
  // Note that Go is now an instance method
  // 注意：Go 是一个实例对象的方法
  void Go() 
  {
     if (!done) { done = true; Console.WriteLine ("Done"); }
  }
}
</pre>

<p>Because both threads call <code>Go()</code>
on the same <code>ThreadTest</code> instance, they share the <code>done</code> field.
This results in "Done" being printed
once instead of twice:</p>
<p>两个线程调用的是同一个 <code>ThreadTest</code> 实例的 <code>Go()</code> 方法，它们共有 <code>done</code> 字段，这就导致程序输出一次 ”Done” 而不是两次。</p>

<pre class="output">
Done
</pre>

<p>Static fields offer another way to share data between
threads. Here’s the same example with <code>done</code> as a
static field:</p>
<p>然而，静态字段的数据共享则是另一回事。下面是一个演示静态字段 <code>done</code> 的示例：</p>

<pre class="sh_csharp">
class ThreadTest 
{
  static bool done;    // Static fields are shared between all threads | 静态字段被所有线程共享
 
  static void Main()
  {
    new Thread (Go).Start();
    Go();
  }
 
  static void Go()
  {
    if (!done) { done = true; Console.WriteLine ("Done"); }
  }
}
</pre>

<p>Both of these examples illustrate another key concept:
that of <a href="part2.html#_Thread_Safety">thread safety</a> (or rather, lack of it!)
The output is actually indeterminate: it’s possible (though unlikely) that “Done”
could be printed twice. If, however, we swap the order of statements in the
<code>Go</code> method, the odds of “Done” being printed twice go up
dramatically:</p>

<p>上面两个示例演示了另一个重要的概念：<a href="part2.html#_Thread_Safety">线程安全</a>。或者说，它们都是线程不安全的，因为程序的输出是不确定的：存在 ”Done” 被打印两次的可能性（尽管很小）。但是，我们将 <code>Go()</code> 方法中的语句颠倒一下顺序的话，打印两次 ”Done” 的可能性就陡然大了起来。</p>
<pre class="sh_csharp">
static void Go()
{
  if (!done) { Console.WriteLine ("Done"); done = true; }
}
</pre>

<pre class="output">Done
Done   <i>(usually! | 很有可能的！)</i></pre>

<p>The problem is that one thread can be evaluating the <code>if</code> statement right as the other thread is executing the
<code>WriteLine</code> statement — before it’s had a chance to set <code>done</code> to true.</p>
<p>问题就在于：一个线程在执行 <code>WriteLine</code> 语句时——此时线程还没来得及改变 <code>done</code>
的值——而正在这个时刻，另一个线程仍然可以将 <code>if</code> 语句判断为真。</p>

<p>The remedy is to obtain an <a href="part2.html#_Locking">exclusive
lock</a> while reading and writing to the common field. C# provides the <a href="part2.html#_Locking">lock</a>
statement for just this purpose:</p>
<p>解决方法就是在读写共有数据时加一个<a href="part2.html#_Locking">独占锁</a>。
C# 中的 <a href="part2.html#_Locking">lock</a> 关键词正是基于此种目的。</p>

<pre class="sh_csharp">
class ThreadSafe 
{
  static bool done;
  static readonly object locker = new object();
 
  static void Main()
  {
    new Thread (Go).Start();
    Go();
  }
 
  static void Go()
  {
    lock (locker)
    {
      if (!done) { Console.WriteLine ("Done"); done = true; }
    }
  }
}
</pre>

<p>When two threads simultaneously contend a lock (in this
case, <code>locker</code>), one thread waits, or <a href="part2.html#_Blocking">blocks</a>, until the lock becomes available. In this case,
it ensures only one thread can enter the critical section of code at a time,
and “Done” will be printed just once. Code that's protected in such a manner — from
indeterminacy in a multithreading context — is called <a href="part2.html#_Thread_Safety">thread-safe</a>.</p>

<p>两个线程同时竞争一个锁（在这里就是 <code>locker</code> ）的情况下，一个线程得到了锁，另一个线程就必须处于等待或者阻塞状态，直到锁解除。这种机制保证了在某一个时刻只有一个线程进入临界区(critical section)，在这个示例中，”Done”
将只会打印一次。像这种在多线程编程中避免不确定性的方式就叫“线程安全”。</p>
<div class="warning">
<p>Shared data is the primary cause of complexity and
obscure errors in multithreading. Although often essential, it pays to keep it
as simple as possible. </p><p>
数据共享是多线程如此复杂和各种隐蔽错误层出不穷的主要原因。尽管在多数情况下很重要，我们还是尽量将多线程处理得越简单越好。</p>
</div>
<p>A thread, while <i>blocked</i>,
doesn't consume CPU resources.</p>
<p><code>阻塞</code> 状态下的线程不消耗CPU资源。</p>
<h2>
	<a name="_Join_and_Sleep">Join and Sleep | Join 和 Sleep</a>
</h2>

<p>You can wait for another thread to end by calling its <code>Join</code> method. For example:</p>
<p>通过调用线程的 <code>Join()</code> 方法，我们可以等待该线程执行完成后再做其他操作。比方说：</p>
<pre class="sh_csharp">
static void Main()
{
  Thread t = new Thread (Go);
  t.Start();
  t.Join();
  Console.WriteLine ("Thread t has ended!");
}
 
static void Go()
{
  for (int i = 0; i &lt; 1000; i++) Console.Write ("y");
}
</pre>

<p>This prints “y” 1,000 times, followed by “Thread t has
ended!” immediately afterward. You can include a timeout when calling <code>Join</code>, either in milliseconds or as a <code>TimeSpan</code>.
It then returns <code>true</code> if the thread ended or <code>false</code> if it timed out.</p>
<p>程序打印1000次字符 ’y’ 后，接着打印 ”Thread t has ended!”。</p>
<p>我们可以给 <code>Join</code> 方法指定一个超时参数，毫秒数或 <code>TimeSpan</code> 都可以。这种情况下如果线程正常结束，<code>Join</code>
方法返回 <code>true</code>，超时则返回 <code>false</code>。</p>
<p>
	<code><a name="_Sleep_And_Yield">Thread.Sleep</a></code> pauses the current
thread for a specified period:</p>
<p>
<code><a name="_Sleep_And_Yield">Thread.Sleep</a></code> 方法将当前线程暂停一段时间：</p>
</p>
<pre class="sh_csharp">
Thread.Sleep (TimeSpan.FromHours (1));  // sleep for 1 hour | 休眠1小时
Thread.Sleep (500);                     // sleep for 500 milliseconds | 休眠500毫秒
</pre>

<p>While waiting on a <code>Sleep</code> or <code>Join</code>, a thread is <i><a href="part2.html#_Blocking">blocked</a></i> and
so does not consume CPU resources.</p>

<p>线程调用 <code>Sleep</code> 或 <code>Join</code> 后，处于<i><a href="part2.html#_Blocking">阻塞状态</a></i>，因此不耗CPU资源。</p>
<div class="note">
	<p>
		<code>Thread.Sleep(0)</code> relinquishes the
thread’s current time slice immediately, voluntarily handing over the CPU to
other threads. Framework 4.0’s new <code>Thread.Yield()</code>
method does the same thing — except that it relinquishes only to threads running
on the <em>same</em> processor.</p>
<p>
<code>Thread.Sleep(0)</code> 方法将当前线程的当前时间片立即交出，自愿将CPU交给其他线程。.Net 4.0
框架中有一个新方法 <code>Thread.Yield()</code> 也具有同样的功能，不同之处在于 <code>Yield</code>
交出的CPU资源只能用于<em>同一颗</em>CPU的其他线程使用。
</p>

<p>
  <code>Sleep(0)</code> or <code>Yield</code>
is occasionally useful in production code for advanced performance tweaks. It’s
also an excellent diagnostic tool for helping to uncover <a href="part2.html#_Thread_Safety">thread safety</a>
issues: if inserting <code>Thread.Yield()</code> anywhere in your code makes or breaks the
program, you almost certainly have a bug.</p>
<p>在生产环境下对性能有更高要求的时候，<code>Sleep(0)</code> 或 <code>Yield</code>
会有一点用处。它也是一个发现<a href="part2.html#_Thread_Safety">线程安全</a>问题的优秀工具：如果在代码中到处插入
  <code>Thread.Yield()</code> 导致程序中断，那你的程序也好不到哪里去了。
</p>
</div>

<h2>
	<a name="_How_Threading_Works">How Threading Works | 线程是如何工作的</a>
</h2>


<p>Multithreading is managed internally by a thread
scheduler, a function the CLR typically delegates to the operating system. A
thread scheduler ensures all active threads are allocated appropriate execution
time, and that threads that are waiting or blocked (for instance, on an
exclusive lock or on user input)  do not consume CPU time.</p>
<p>多线程由一个内部的线程调度器来管理，这是典型的 CLR 委派给操作系统的任务。线程调度器保证所有活动的线程都恰当地分配了执行时间，保证处于等待或阻塞状态下的进程不消耗CPU时间。</p>

<p>On a single-processor computer, a thread scheduler
performs <i>time-slicing</i> — rapidly switching
execution between each of the active threads. Under Windows, a time-slice is
typically in the tens-of-milliseconds region — much larger than the CPU overhead
in actually switching context between one thread and another (which is
typically in the few-microseconds region).</p>
<p>在单处理器的电脑中，线程调度器是执行<i>时间切片</i>——在活动线程之间快速地切换执行顺序——来管理多线程。Windows环境下，一个时间片大约是数10毫秒，这个时间大大超出了
CPU 在不同线程间切换环境时的时间消耗（大约是几毫秒）。</p>

<p>On a multi-processor computer, multithreading is
implemented with a mixture of time-slicing and genuine concurrency, where
different threads run code simultaneously on different CPUs. It’s almost
certain there will still be some time-slicing, because of the operating system’s
need to service its own threads — as well as those of other applications.</p>
<p>在多处理器的电脑中，多线程是通过时间切片和真正的并发混合实现的。不同线程在不同 CPU 上实现了真正的同时运行。几乎可以肯定的是，时间切片仍然存在，因为操作系统必须满足它自己的线程，这跟其他的应用程序是一样的道理。</p>

<p>A thread is said to be <i>preempted</i>
when its execution is interrupted due to an external factor such as
time-slicing. In most situations, a thread has no control over when and where
it’s preempted.</p>
<p>据说被外部因素（如时间切片）中断的线程具有<i>较高</i>的优先级。在大多数情况下，线程无法控制自身在什么时候、何种情况下具有这种较高的优先级。</p>

<h2>
	<a name="_Threads_vs_Processes">Threads vs Processes | 线程 VS 进程</a>
</h2>

<p>A thread is analogous to the operating system process in
which your application runs. Just as processes run in parallel on a computer,
threads run in parallel <em>within a single process</em>. Processes are fully
isolated from each other; threads have just a limited degree of isolation. In
particular, threads share (heap) memory with other threads running in the same
application. This, in part, is why threading is useful: one thread can fetch
data in the background, for instance, while another thread can display the data
as it arrives.</p>
<p>线程就是应用程序的“进程”，这跟进程与操作系统的关系类似。进程是并行地运行在在电脑上，而线程是并行地运行在<em>某个进程中</em>。进程是绝对的相对独立，线程则具有一定程度的独立性。最突出的一点就是同一进程内的线程共享(堆)内存，而这也正是线程之所以用途很大的部分原因：比如说，一个线程在后台取数据，另一个线程可以显示数据。</p>
<h2>
	<a name="_Threadings_Uses_and_Misuses">Threading’s Uses and Misuses | 线程的好处和缺点</a>
</h2>

<p>Multithreading has many uses; here are the most common:</p>
<p>使用多线程有很多好处，下面是一些最常用的：</p>
<dl>
	<dt>Maintaining a responsive user interface</dt>
	<dt>维持UI的响应性</dt>
	<dd>By running time-consuming tasks on a parallel “worker”
thread, the main UI thread is free to continue processing keyboard and mouse
events.</dd>
    <dd>将十分耗时的任务交给并行线程执行，使主界面能够处理其他键盘和鼠标事件。</dd>
	<dt>Making efficient use of an otherwise blocked CPU</dt>
	<dt>充分利用闲置的CPU</dt>
	<dd>Multithreading is useful when a thread is awaiting a
response from another computer or piece of hardware. While one thread is
blocked while performing the task, other threads can take advantage of the
otherwise unburdened computer.</dd>
    <dd>线程阻塞的情况下，多线程将十分有用。一个线程执行任务时发生阻塞，或许在等候其他主机或硬件的响应，其他线程就可以利用闲置的CPU资源。</dd>
	<dt>Parallel programming</dt>
	<dt>并行编程</dt>
	<dd>Code that performs intensive calculations can execute
faster on multicore or multiprocessor computers if the workload is shared among
multiple threads in a “divide-and-conquer” strategy (see <a href="part5.html">Part 5</a>).</dd>
    <dd>采用“分治策略”（见 <a href="part5.html">Part 5</a>）将工作量分担到各个线程来完成，在多核/多处理器的电脑上完成海量计算任务往往有很好的表现。</dd>
	<dt>Speculative execution</dt>
	<dt>预测执行</dt>
	<dd>On multicore machines, you can sometimes improve
performance by predicting something that might need to be done, and then doing
it ahead of time. <a href="http://www.linqpad.net/">LINQPad</a> uses this
technique to speed up the creation of new queries. A variation is to run a
number of different algorithms in parallel that all solve the same task.
Whichever one finishes first “wins” — this is effective when you can’t know ahead
of time which algorithm will execute fastest.</dd>
    <dd>在多核机器上，你可以通过预测哪些事情需要做并提前完成它们来提高性能。<a href="http://www.linqpad.net/">LINQPad</a>
	正是使用这种技术提高创建查询的速度。它的独到之处在于并行地运行多个算法解决同一个问题，任何一个算法结束运行，问题就解决了。这是非常有效率的做法，因为你不可能提前知道哪个算法最先完成任务。</dd>
	<dt>Allowing requests to be processed simultaneously</dt>
	<dt>同步处理请求</dt>
	<dd>On a server, client requests can arrive concurrently and
so need to be handled in parallel (the .NET Framework creates threads for this
automatically if you use ASP.NET, WCF, Web Services, or Remoting). This can
also be useful on a client (e.g., handling peer-to-peer networking — or even
multiple requests from the user).</dd>
<dd>服务器接受用户请求可能是同时的，这就要求服务器必须同时处理这些请求（如果使用ASP.NET、WCF、Web Services 或者 Remoting
开发的话，.NET框架会自动创建线程来处理这些问题）。这一点在客户端非常有用（如处理P2P网络乃至用户多重请求）。</dd>
</dl>

<p>With technologies such as ASP.NET and WCF, you may be <a href="part2.html#_Thread_Safety_in_Application_Servers">unaware that multithreading is even taking place</a> — unless
you access shared data (perhaps via static fields) without appropriate <a href="part2.html#_Locking">locking</a>, <a href="part2.html#_Thread_Safety_in_Application_Servers">running afoul of
thread safety.</a></p>
<p>配合 ASP .NET 和 WCF 等技术，你或许根本<a href="part2.html#_Thread_Safety_in_Application_Servers">不会意识到多线程的存在</a>，除非你在读写共享数据（可能是通过静态属性）时没有正确使用<a href="part2.html#_Locking">锁</a>，或者使用了<a href="part2.html#_Thread_Safety_in_Application_Servers">其他线程不安全的作法</a>。</p>

<p>Threads also come with strings attached. The biggest is
that multithreading can increase complexity. Having lots of threads does not in
and of itself create much complexity; it’s the interaction between threads
(typically via shared data) that does. This applies whether or not the
interaction is intentional, and can cause long development cycles and an
ongoing susceptibility to intermittent and nonreproducible bugs. For this
reason, it pays to keep interaction to a minimum, and to stick to simple and
proven designs wherever possible. This article focuses largely on dealing with
just these complexities; remove the interaction and there’s much less to say!</p>

<p>多线程同样也有其缺点。最大的问题就在于多线程增加了程序的复杂性。多线程本身并不会增加复杂性，线程间的交互（典型的例子就是共享数据）才是原因所在。不管是有意还是无意间产生线程间的交互，这种影响都会发生。线程间的交互同样也会延长开发周期，导致系统不稳定或者一些不可预测的
bug。基于这一点，有必要保持最小限量的线程交互，尽量采用简单的、可靠的设计，减少不必要的交互。本文大部分篇幅正是集中在处理线程引起的复杂性问题上。</p>

<div class="note"><p>A good strategy is to encapsulate multithreading logic into
reusable classes that can be independently examined and tested. The Framework
itself offers many higher-level threading constructs, which we cover later. </p>

<p>将多线程逻辑封装到一个独立的、可测试的模块是一个不错的策略。.Net
框架提供了很多高水平的线程构造方法，在接下来的文章中，我们会陆续介绍。</p>
</div>

<p>Threading also incurs a resource and CPU cost in
scheduling and switching threads (when there are more active threads than CPU
cores) — and there’s also a creation/tear-down cost. Multithreading will not
always speed up your application — it can even slow it down if used excessively
or inappropriately. For example, when heavy disk I/O is involved, it can be
faster to have a couple of worker threads run tasks in sequence than to have 10
threads executing at once. (In <a href="part4.html#_Signaling_with_Wait_and_Pulse">Signaling with
Wait and Pulse</a>, we describe how to implement a <a href="part4.html#_Wait_Pulse_Producer_Consumer_Queue">producer/consumer queue</a>, which provides
just this functionality.)</p>

<p>多线程还会导致额外的系统资源的开销。调度和切换线程同样需要系统资源，尤其是活动线程比 CPU
核心多的情况下。创建/销毁这些额外的资源也是一笔开销。使用多线程不一定会提高程序运行速度，滥用多线程或不恰当地使用多线程甚至会导致程序运行变慢。比方说，涉及到笨重的磁盘
I/O 操作时，少数几个工作线程顺序执行比 10 个线程同时执行更快。（在 <a href="part4.html#_Signaling_with_Wait_and_Pulse">使用
Wait 和 Pulse 发信号</a> 一节中，我会介绍一种解决这个问题的方法：<a href="part4.html#_Wait_Pulse_Producer_Consumer_Queue">生产者/消费者队列</a>。</p>
<h1>
	<a name="_Creating_and_Starting_Threads">Creating and Starting Threads | 创建和启动线程</a>
</h1>

<p>As we saw in the introduction, threads are created using
the <code>Thread</code> class’s constructor, passing in a <code>ThreadStart</code> delegate which indicates where execution
should begin.  Here’s how the <code>ThreadStart</code> delegate
is defined:</p>
<p>在简介一章，我们介绍过，线程是通过 <code>Thread</code> 类的构造函数来创建的。构造线程时，我们传递一个 <code>ThreadStart</code> 类型的代理给构造函数，这个代理告诉线程从哪里开始执行。<code>ThreadStart</code> 是这样定义的：</p>
<pre class="sh_csharp">
public delegate void ThreadStart();
</pre>

<p>Calling <code>Start</code> on the thread
then sets it running. The thread continues until its method returns, at which
point the thread ends. Here’s an example, using the expanded C# syntax for
creating a <code>TheadStart</code> delegate:</p>
<p>调用 <code>Start</code> 后，线程开始运行，直到代理运行结束，线程才终止。下面的示例演示如何使用 C# 的扩展语法创建 <code>ThreadStart</code> 代理：</p>

<pre class="sh_csharp">
class ThreadTest
{
  static void Main() 
  {
    Thread t = new Thread (new ThreadStart (Go));
 
    t.Start();   // Run Go() on the new thread. | 在新建线程中运行 Go()
    Go();        // Simultaneously run Go() in the main thread. | 同时在主线程中运行 Go()
  }
 
  static void Go()
  {
    Console.WriteLine ("hello!");
  }
}
</pre>

<p>In this example, thread <code>t</code>
executes <code>Go()</code> — at (much) the same time the main
thread calls <code>Go()</code>. The result is two near-instant
hellos.</p>
<p>在这个示例中，几乎在线程 <code>t</code> 执行 <code>Go()</code> 方法的同时，主线程中也调用了 <code>Go()</code>
方法，程序的输出是两个 "Hello!"。</p>

<p>A thread can be created more conveniently by specifying
just a method group — and allowing C# to infer the <code>ThreadStart</code>
delegate:</p>
<p>传递方法名能更方便地创建线程，生成 <code>ThreadStart</code> 代理的工作由 C# 完成。</p>

<pre class="sh_csharp">
Thread t = new Thread (Go);    // No need to explicitly use ThreadStart | 不必显式地使用 ThreadStart
</pre>

<p>Another shortcut is to use a lambda expression or
anonymous method:</p>
<p>另一个简便方法是使用 lambda 表达式或匿名方法：</p>

<pre class="sh_csharp">
static void Main()
{
  Thread t = new Thread ( () =&gt; Console.WriteLine ("Hello!") );
  t.Start();
}
</pre>

<h2>
	<a name="_Passing_Data_to_a_Thread">Passing Data to a Thread | 将数据传给线程</a>
</h2>

<p>The easiest way to pass arguments to a thread’s target
method is to execute a lambda expression that calls the method with the desired
arguments:</p>
<p>向线程的目标方法传递参数最简单的方法是通过 lambda 表达式将需要的参数传递给线程的目标方法。</p>

<pre class="sh_csharp">
static void Main()
{
  Thread t = new Thread ( <b>() =&gt; Print ("Hello from t!")</b> );
  t.Start();
}
 
static void Print (string message) 
{
  Console.WriteLine (message);
}
</pre>

<p>With this approach, you can pass in any number of
arguments to the method. You can even wrap the entire implementation in a multi-statement
lambda:</p>
<p>采用这种方法，你可以向目标方法传递任意数目的参数，甚至可以在 lambda 表达式中用多行代码将整个业务封闭起来。</p>

<pre class="sh_csharp">
new Thread (() =&gt;
{
  Console.WriteLine ("I'm running on another thread!");
  Console.WriteLine ("This is so easy!");
}).Start();
</pre>

<p>You can do the same thing almost as easily in C# 2.0 with
anonymous methods:</p>
<p>在 C# 2.0 中用匿名方法也可以达到同样的效果：</p>

<pre class="sh_csharp">
new Thread (<b>delegate()</b>
{
  ...
}).Start();
</pre>

<p>Another technique is to pass an argument into <code>Thread</code>’s <code>Start</code> method:</p>
<p>另一个技巧是向 <code>Thread</code> 类的 <code>Start</code> 方法传递参数：</p>

<pre class="sh_csharp">
static void Main()
{
  Thread t = new Thread (Print);
  t.Start <b>("Hello from t!")</b>;
}
 
static void Print (object messageObj)
{
  string message = (string) messageObj;   // We need to cast here | 这里需要类型转换
  Console.WriteLine (message);
}
</pre>

<p>This works because <code>Thread</code>’s
constructor is overloaded to accept either of two delegates:</p>

<p>这样做能奏效是因为 <code>Thread</code> 类的构造函数经过重载，能接受这两种代理：</p>

<pre class="sh_csharp">
public delegate void ThreadStart();
public delegate void ParameterizedThreadStart (object obj);
</pre>

<p>The limitation of <code>ParameterizedThreadStart</code>
is that it accepts only one argument. And because it’s of type <code>object</code>, it usually needs to be cast.</p>
<p><code>ParameterizedThreadStart</code> 有一个局限，它只能接受一个参数。参数是 <code>object</code> 类型的，还需要类型转换。</p>

<h3>Lambda expressions and captured variables</h3>

<p>As we saw, a lambda expression is the most powerful way to
pass data to a thread. However, you must be careful about accidentally
modifying <em>captured variables</em> after starting the thread, because these
variables are shared. For instance, consider the following:</p>
<p>我们知道，lambda 表达式是一种非常强大的向线程传递数据的方法。不过你得小心，<em>传入变量</em>在线程启动后可能会意外地被修改，原因在于这些变量是为所有线程共享的。</p>

<pre class="sh_csharp">
for (int i = 0; i &lt; 10; i++)
  new Thread (() =&gt; Console.Write (i)).Start();
</pre>

<p>The output is nondeterministic! Here’s a typical result:</p>
<p>输出是不确定的！典型的输出如下：</p>
<pre class="output">
0223557799
</pre>

<p>The problem is that the <code>i</code>
variable refers to the <em>same</em> memory location throughout the loop’s
lifetime. Therefore, each thread calls <code>Console.Write</code>
on a variable whose value may change as it is running!</p>
<p>问题出在变量 <code>i</code> 在循环的生命周期内指向同一个内存地址，而每个线程调用 <code>Console.Write</code> 时输出一个随时在变的变量。</p>

<div class="note"><p>This is analogous to the problem we describe in “Captured
Variables” in Chapter 8 of <a href="http://www.albahari.com/nutshell/">C# 4.0
in a Nutshell</a>. The problem is less about multithreading and more about C#'s
rules for capturing variables (which are somewhat undesirable in the case of <code>for</code> and <code>foreach</code> loops).</p>
<p>这个问题与<a href="http://www.albahari.com/nutshell/">言简意赅话 C# 4.0</a> 一书的第 8 章“传入变量”中描述的问题有点类似，它更多的是 C#
关于传入变量的规则，而不是多线程的问题（传入变量是 <code>for</code> 循环和 <code>foreach</code> 循环不想碰到的问题）。</p>
</div>

<p> The solution is to use a temporary variable as follows:</p>
<p>增加一个临时变量就可以解决这个问题：</p>
<pre class="sh_csharp">
for (int i = 0; i &lt; 10; i++)
{
  int temp = i;
  new Thread (() =&gt; Console.Write (temp)).Start();
}
</pre>

<p>Variable <code>temp</code> is now local to
each loop iteration. Therefore, each thread captures a different memory
location and there’s no problem. We can illustrate the problem in the earlier
code more simply with the following example:</p>
<p>对于每一次循环来说，变量 <code>temp</code> 都是局部变量，每一个线程接受的是不同的内存地址，这样就不会出错了。我们用之前的一个示例来简单重现一下这个错误，如下所示：</p>

<pre class="sh_csharp">
string text = "t1";
Thread t1 = new Thread ( () =&gt; Console.WriteLine (text) );
 
text = "t2";
Thread t2 = new Thread ( () =&gt; Console.WriteLine (text) );
 
t1.Start();
t2.Start();
</pre>

<p>Because both lambda expressions capture the same <code>text</code> variable, <code>t2</code> is printed
twice:</p>
<p>因为两个 lambda 表达式都接受了同一个 <code>text</code> 变量，<code>t2</code> 会打印两次：</p>
<pre class="output">
t2
t2
</pre>

<h2>
	<a name="_Naming_Threads">Naming Threads | 为线程命名</a>
</h2>

<p>Each thread has a <code>Name</code> property
that you can set for the benefit of debugging. This is particularly useful in
Visual Studio, since the thread’s name is displayed in the Threads Window and
Debug Location toolbar. You can set a thread’s name just once; attempts to
change it later will throw an exception.</p>
<p>每一个线程都有一个 <code>Name</code> 属性。设置 <code>Name</code> 属性有利于调试程序，尤其是在 Visual Studio
环境下，因为线程名直观地展示在 Thread Window 窗口和 Debug Location 工具条中。线程名只能设置一次，再次修改会抛出异常。</p>

<p>The static <code>Thread.CurrentThread</code>
property gives you the currently executing thread. In the following example, we
set the main thread’s name:</p>
<p>静态属性 <code>Thread.CurrentThread</code> 返回当前正在执行的线程。在下面的示例中，我们为主线程设置线程名：</p>

<pre class="sh_csharp">
class ThreadNaming
{
  static void Main()
  {
    Thread.CurrentThread.Name = "main";
    Thread worker = new Thread (Go);
    worker.Name = "worker";
    worker.Start();
    Go();
  }
 
  static void Go()
  {
    Console.WriteLine ("Hello from " + Thread.CurrentThread.Name);
  }
}
</pre>

<h2>
	<a name="_Foreground_and_Background_Threads">Foreground and Background Threads | 前台线程与后台线程</a>
</h2>

<p>By default, threads you create explicitly are <i>foreground threads</i>. Foreground threads keep the
application alive for as long as any one of them is running, whereas <i>background threads</i> do not. Once all foreground
threads finish, the application ends, and any background threads still running
abruptly terminate.</p>
<p>显式创建的线程默认是<i>前台线程</i>。只要任何一个前台线程在运行，应用程序就不会终止，而<i>后台线程</i>则不然。当所有前台线程结束时，应用程序就会终止，然而后台线程却仍然在运行。</p>

<div class="note"><p>A thread’s foreground/background status has no relation to its
priority or allocation of execution time.</p>
<p>一个线程是前台线程还是后台线程与它的优先级或分配的执行时间没有联系。</p>
</div>

<p>You can query or change a thread’s background status using
its <code>IsBackground</code> property. Here’s an example:</p>
<p>检查 <code>IsBackground</code> 属性可以知道一个线程是否为后台线程，设置 <code>IsBackground</code> 可以改变线程的后台线程状态。如下所示：</p>

<pre class="sh_csharp">
class PriorityTest
{
  static void Main (string[] args)
  {
    Thread worker = new Thread ( () =&gt; Console.ReadLine() );
    if (args.Length &gt; 0) worker.IsBackground = true;
    worker.Start();
  }
}
</pre>

<p>If this program is called with no arguments, the worker
thread assumes foreground status and will wait on the <code>ReadLine</code>
statement for the user to press Enter. Meanwhile, the main thread exits, but
the application keeps running because a foreground thread is still alive.</p>
<p>这个程序不带参数运行时，工作线程 <code>worker</code> 为前台线程，它的 <code>ReadLine</code> 语句等待用户按下 Enter
键，同时主线程退出。但是程序仍然在运行，因为有一个前台线程仍然处于活跃状态。</p>

<p>On the other hand, if an argument is passed to <code>Main()</code>, the worker is assigned background status, and the
program exits almost immediately as the main thread ends (terminating the <code>ReadLine</code>).</p>
<p>另一方面，如果传给 <code>Main()</code> 函数一个参数，工作线程 <code>worker</code>
被赋为后台线程，程序在主线程结束后立刻退出（同时终止了 <code>ReadLine</code>）。</p>

<p>When a process terminates in this manner, any <code>finally</code> blocks in the execution stack of background
threads are circumvented. This is a problem if your program employs <code>finally</code> (or <code>using</code>) blocks to
perform cleanup work such as releasing resources or deleting temporary files.
To avoid this, you can explicitly wait out such background threads upon exiting
an application. There are two ways to accomplish this:</p>
<p>进程以这样一种方式结束运行，那么后台线程的执行堆栈上的所有 <code>finally</code> 代码块都将被破坏。如果程序使用 <code>finally</code>
或者 <code>using</code> 来执行资源释放或删除临时文件，那么你将会遇到一些麻烦。为了避免出现这些问题，你可以明确要求程序在后台线程结束后退出。有两种方法：</p>

<ul>
	<li>If you’ve created the thread yourself, call <code><a href="#_Join_and_Sleep">Join</a></code> on the thread.</li>
	<li>线程由你本人创建，调用线程的 <code><a href="#_Join_and_Sleep">Join</a></code> 方法。</li>
	<li>If you’re on a <a href="#_Thread_Pooling">pooled thread</a>, use
an <a href="part2.html#_Signaling_with_Event_Wait_Handles">event wait handle</a>.</li>
    <li>线程是从线程池中取出的，使用<a href="part2.html#_Signaling_with_Event_Wait_Handles">事件等待对象</a>。</li>
</ul>

<p>In either case, you should specify a timeout, so you can
abandon a renegade thread should it refuse to finish for some reason. This is
your backup exit strategy: in the end, you want your application to
close — without the user having to enlist help from the Task Manager!</p>
<p>不管哪种方法，你必须指定一个超时参数，以防止线程由于某种原因无法完成执行。这实际上是一个备用的结束策略，你希望程序在用户不必动用任务管理器的情况下结束运行。</p>

<div class="note"><p>If a user uses the Task Manager to forcibly end a .NET
process, all threads “drop dead” as though they were background threads. This
is observed rather than documented behavior, and it could vary depending on the
CLR and operating system version.</p>
<p>如果用户通过任务管理器结束一个 .NET 进程，所有线程都结束了（什么像后台线程是什么意思？）这看起来更像是文档中描述的行为，而且因 CLR 和操作系统而异。</p>
</div>

<p>Foreground threads don’t require this treatment, but you
must take care to avoid bugs that could cause the thread not to end. A common
cause for applications failing to exit properly is the presence of active
foreground threads.</p>
<p>前台线程不需要这种处理，但是必须要避免导致线程不能结束的 bug。应用程序不能正常退出的一个常见原因正是活跃的前台线程的存在。</p>

<h2>
	<a name="_Thread_Priority">Thread Priority | 线程优先级</a>
</h2>

<p>A thread’s <code>Priority</code> property
determines how much execution time it gets relative to other active threads in
the operating system, on the following scale:</p>
<p>一个线程的 <code>Priority</code> 属性决定了操作系统分配给它的执行时间与其他活跃线程相比是更多还是更少，具体说来是这样规定的：</p>

<pre class="sh_csharp">
enum ThreadPriority { Lowest, BelowNormal, Normal, AboveNormal, Highest }
</pre>

<p>This becomes relevant only when multiple threads are
simultaneously active.</p>
<p>只有在同时活跃多个线程的情况下，这个相对值才有意义。</p>

<div class="warning"><p>Think carefully before elevating a thread’s priority — it
can lead to problems such as resource starvation for other threads.</p>
<p>提升线程的优先级时，必须要仔细考量一下，不能出现其他线程没有资源分配的情况。</p>
</div>
<p>Elevating a thread’s priority doesn’t make it capable of
performing real-time work, because it’s still throttled by the application’s
process priority. To perform real-time work, you must also elevate the process
priority using the <code>Process</code> class in <code>System.Diagnostics</code> (we didn’t tell you how to do this):</p>
<p>提升线程的优先级，并不意思着它就能实时地工作，它同样受限于所在进程的优先级。使用 <code>System.Diagnostics.Process</code> 类提升了相应进程的优先级后，线程才能实时工作。</p>

<pre class="sh_csharp">
using (Process p = Process.GetCurrentProcess())
  p.PriorityClass = ProcessPriorityClass.High;
</pre>

<p>
	<code>ProcessPriorityClass.High</code> is
actually one notch short of the highest priority: <code>Realtime</code>.
Setting a process priority to <code>Realtime</code> instructs the
OS that you never want the process to yield CPU time to another process. If
your program enters an accidental infinite loop, you might find even the
operating system locked out, with nothing short of the power button left to
rescue you! For this reason, <code>High</code> is usually the
best choice for real-time applications.</p>
<p><code>ProcessPriorityClass.High</code> 实际上是仅次于最高优先级 <code>Realtime</code> 的优先级。将一个进程设为 <code>Realtime</code>
意味着你告诉操作系统，你决不会把 CPU 时间交给其他进程。一旦程序陷入死循环，你会发现，连操作系统都无能为力了，最后只剩下按电源开关一个办法。正因为如此，<code>High</code> 往往是实时应用程序最好的选择。</p>

<div class="warning"><p>If your real-time application has a user interface,
elevating the process priority gives screen updates excessive CPU time, slowing
down the entire computer (particularly if the UI is complex). Lowering the main
thread’s priority in conjunction with raising the process’s priority ensures
that the real-time thread doesn’t get preempted by screen redraws, but doesn’t
solve the problem of starving other applications of CPU time, because the
operating system will still allocate disproportionate resources to the process
as a whole. An ideal solution is to have the real-time worker and user
interface run as separate applications with different process priorities,
communicating via Remoting or memory-mapped files. Memory-mapped files are
ideally suited to this task; we explain how they work in Chapters 14 and 25 of <a href="http://www.albahari.com/nutshell/">C# 4.0 in a Nutshell</a>.</p>
<p>如果你的实时应用程序拥有用户界面(UI)，提升进程的优先级将会使得屏幕更新拥有过多的 CPU
时间，整个电脑运行都会变慢，尤其是 UI 相当复杂的情况下。降低主线程的优先级的同时提升进程的优先级，这种做法可以保证应用程序不会被屏幕重绘挤占资源，但仍然不能解决其他进程无资源可分配的问题。因为操作系统还是把绝大多数资源分配给一个进程。一个较理想的解决方案就是，将实时工作和 UI
分离成两个单独的程序，为他们赋不同的优先级。两个进程通过远程或者内存映射文件通信。内存映射文件完美地解决了这个问题。我会在 <a href="http://www.albahari.com/nutshell/">言简意赅话 C# 4.0</a> 一书的第 14 章和 25 章中介绍这个话题。</p>
</div>

<p>Even with an elevated process priority, there’s a limit to
the suitability of the managed environment in handling hard real-time
requirements. In addition to the issues of latency introduced by automatic garbage
collection, the operating system may present additional challenges — even for
unmanaged applications — that are best solved with dedicated hardware or a
specialized real-time platform.</p>
<p>即使是具有较高优先级的进程，在托管环境下处理硬实时请求时仍然存在一些兼容性问题。此外，操作系统还要面临很多挑战，如垃圾自动回收机制的引入而导致的一些潜在问题，这就涉及专用硬件或特殊的实时平台。</p>

<h2>
	<a name="_Exception_Handling">Exception Handling | 异常处理</a>
</h2>

<p>Any <code>try</code>/<code>catch</code>/<code>finally</code> blocks in scope when a thread is created are of no
relevance to the thread when it starts executing. Consider the following
program:</p>
<p>线程开始执行后，与它在同一个作用域内的 <code>try</code>/<code>catch</code>/<code>finally</code> 代码块就跟线程没有关系了。琢磨一下这个示例：</p>

<pre class="sh_csharp">
public static void Main()
{
  try
  {
    new Thread (Go).Start();
  }
  catch (Exception ex)
  {
    // We'll never get here!
    // 程序不会运行到这里！
    Console.WriteLine ("Exception!");
  }
}
 
static void Go() { throw null; }   // Throws a NullReferenceException | 抛出 NullReferenceException 异常
</pre>

<p>The <code>try</code>/<code>catch</code>
statement in this example is ineffective, and the newly created thread will be
encumbered with an unhandled <code>NullReferenceException</code>.
This behavior makes sense when you consider that each thread has an independent
execution path.</p>
<p>这个例子中的 <code>try</code>/<code>catch</code> 代码块是无效的，新创建的线程被一个没有处理的 <code>NullReferenceException</code>
异常中断。只要想想，每个线程都拥有独立的执行路径，你就会觉得出现这种现象很合情合理。</p>

<p>The remedy is to move the exception handler into the <code>Go</code> method:</p>
<p>将异常处理挪到 <code>Go</code> 方法中就可以解决这个问题。</p>
<pre class="sh_csharp">
public static void Main()
{
   new Thread (Go).Start();
}
 
static void Go()
{
  try
  {
    // ...
    throw null;    // The NullReferenceException will get caught below | NullReferenceException 异常在下面捕捉得到
    // ...
  }
  catch (Exception ex)
  {
    // Typically log the exception, and/or signal another thread
    // that we've come unstuck
    // 典型的做法是记录这次异常，和/或者向其他线程发消息：我卡住了！
    // ...
  }
}
</pre>

<p>You need an exception handler on all thread entry methods
in production applications — just as you do (usually at a higher level, in the
execution stack) on your main thread. An unhandled exception causes the whole
application to shut down. With an ugly dialog!</p>
<p>正如在生产环境中为主线程编写异常处理事件一样，你需要在每一个线程编上做同样的事情。一个未处理的异常会导致程序异常退出，还弹出一个丑陋的对话框。</p>

<div class="note"><p>In writing such exception handling blocks, rarely would you <em>ignore</em>
the error: typically, you’d log the details of the exception, and then perhaps
display a dialog allowing the user to automatically submit those details to
your web server. You then might shut down the application — because it’s possible
that the error corrupted the program’s state. However, the cost of doing so is
that the user will lose his recent work — open documents, for instance.</p>
<p>在编写异常处理代码时，你肯定不会对产生的错误视而不见。典型的做法是将异常详情记录下来，或许还会弹出对话框提示用户将异常上传至服务器，最后，程序会被关闭，因为程序已经被破坏无法继续运行。但是用户会丢失最近的工作，比方说打开的文件等。</p>
</div>
<div class="warning">
	<p>The “global” exception handling events for WPF and
Windows Forms applications (<code>Application.DispatcherUnhandledException</code>
and <code>Application.ThreadException</code>) fire only for
exceptions thrown on the main UI thread. You still must handle exceptions on
worker threads manually.</p>
<p>WPF 程序和窗体应用程序的“全局”异常处理事件（<code>Application.DispatcherUnhandledException</code>
和 <code>Application.ThreadException</code>）只处理主 UI 线程抛出的异常。工作线程的异常处理工作仍然需要手动维护。</p>
	<p>
		<code>AppDomain.CurrentDomain.UnhandledException</code>
fires on any unhandled exception, but provides no means of preventing the
application from shutting down afterward.</p>
<p><code>AppDomain.CurrentDomain.UnhandledException</code> 可以处理任何未被处理的异常，但是它不能防止程序异常退出。</p>
</div>

<p>There are, however, some cases where you don’t need to
handle exceptions on a worker thread, because the .NET Framework does it for
you. These are covered in upcoming sections, and are:</p>
<p>当然，也有一些工作线程的异常不需要用户处理，这些工作由 .NET 框架完成了。下面就有一些，在后续章节中会介绍到：</p>

<ul>
	<li>
		<a href="#_Asynchronous_delegates">Asynchronous delegates | 异步代理</a>
	</li>
	<li>
		<code>
			<a href="part3.html#_BackgroundWorker">BackgroundWorker | 背景工作线程？</a>
		</code>
	</li>
	<li>The <a href="part5.html#_The_Parallel_Class">Task Parallel Library </a>
(conditions apply) | 任务并行库（部分情况下适用）</li>
</ul>

<h1>
	<a name="_Thread_Pooling">Thread Pooling | 线程池</a>
</h1>

<p>Whenever you start a thread, a few hundred microseconds
are spent organizing such things as a fresh private local variable stack. Each
thread also consumes (by default) around 1 MB of memory. The <i>thread pool</i> cuts these overheads by sharing and
recycling threads, allowing multithreading to be applied at a very granular
level without a performance penalty. This is useful when leveraging multicore
processors to execute computationally intensive code in parallel in
“divide-and-conquer” style.</p>
<p>创建一个新线程，操作系统会花费几百微秒用于维护栈，还会占用 1 MB 左右的内存。<i>线程池</i>可以减少这些开销，因为线程池共享和重复利用线程，保证性能的前提下在一个微观层次实现多线程。采用“分治策略”处理大量计算任务时，线程池将发挥重要作用。</p>

<p>The thread pool also keeps a lid on the total number of
worker threads it will run simultaneously. Too many active threads throttle the
operating system with administrative burden and render CPU caches ineffective.
Once a limit is reached, jobs queue up and start only when another finishes.
This makes arbitrarily concurrent applications possible, such as a web server.
(The <i>asynchronous method pattern</i> is an
advanced technique that takes this further by making highly efficient use of
the pooled threads; we describe this in Chapter 23 of <a href="http://www.albahari.com/nutshell/">C# 4.0 in a Nutshell</a>).</p>
<p class="ch">线程池对同时运行的线程的数量有一个限制。太多线程会给操作系统增加管理任务、降低 CPU
缓存效率，从而导致系统运行变慢。当线程数量达到上限，新任务必须排队等候其他任务完成后才能继续。线程池的使用使得随意性的并发应用，如网页服务程序，成为可能。
（<i>异步方法模式</i>这项技术对池线程的使用效率更高，我们会在 <a href="http://www.albahari.com/nutshell/">言简意赅话 C# 4.0</a>
一书的第 23 章中更深入地讨论这个话题。）</p>

<p>There are a number of ways to enter the thread pool:</p>
<p>有很多种方法可以进入线程池：</p>

<ul>
	<li>Via the <a href="part5.html#_The_Parallel_Class">Task Parallel Library</a> (from Framework 4.0)</li>
	<li class="ch">通过<a href="part5.html#_The_Parallel_Class">任务并行库(TPL)</a>（从 .NET 4.0 起）</li>
	<li>By calling <code><a href="#_QueueUserWorkItem">ThreadPool.QueueUserWorkItem</a></code></li>
	<li class="ch">调用 <code><a href="#_QueueUserWorkItem">ThreadPool.QueueUserWorkItem</a></code> 方法</li>
	<li>Via <a href="#_Asynchronous_delegates">asynchronous delegates</a></li>
	<li class="ch">通过<a href="#_Asynchronous_delegates">异步代理</a>机制</li>
	<li>Via <code><a href="part3.html#_BackgroundWorker">BackgroundWorker</a></code></li>
	<li class="ch">通过 <code><a href="part3.html#_BackgroundWorker">BackgroundWorker</a></code> 类</li>
</ul>

<div class="note">
	<p>The following constructs use the thread pool <em>indirectly</em>:</p>
	<p class="ch">下面这些方法<em>间接地</em>使用了线程池：</p>
	<ul>
		<li>WCF, Remoting, ASP.NET, and ASMX Web Services application servers</li>
		<li class="ch">WCF, Remoting, ASP.NET, 以及 ASMX Web Services 应用程序服务器</li>
		<li>
		  <code><a href="part3.html#_Multithreaded_Timers">System.Timers.Timer</a></code> and
		  <code><a href="part3.html#_Multithreaded_Timers">System.Threading.Timer</a></code></li>
        <li class="ch">
		  <code><a href="part3.html#_Multithreaded_Timers">System.Timers.Timer</a></code> 类和
		  <code><a href="part3.html#_Multithreaded_Timers">System.Threading.Timer</a></code> 类</li>
		<li>Framework methods that end in <em>Async</em>, such as those on <code>WebClient</code>
		  (the <em><a href="part3.html#_Event-Based_Asynchronous_Pattern">event-based asynchronous pattern</a></em>),
		  and most <code>Begin</code><span class="Replaceable">XXX</span> methods (the <em>asynchronous programming model</em> pattern)</li>
		<li class="ch">.NET 中以 <em>Async</em> 结尾的方法（<em><a href="part3.html#_Event-Based_Asynchronous_Pattern">基于事件的异步模式</a></em>）, 像
		  <code>WebClient</code> 类中的某些方法；以及大多数形如 <code>Begin</code><span class="Replaceable">XXX</span>
		  的方法（<em>异步编程模型</em> 模式)</li>
		<li>PLINQ</li>
		<li class="ch">并行 LINQ</li>
	</ul>
</div>

<p>The <i>Task Parallel Library</i>
(TPL) and PLINQ are sufficiently powerful and high-level that you’ll want to
use them to assist in multithreading even when thread pooling is unimportant. We
discuss these in detail <a href="part5.html">in Part 5</a>; right
now, we'll look briefly at how you can use the <code><a href="part5.html#_Task_Parallelism">Task</a></code> class as a simple means of running a delegate
on a pooled thread.</p>

<div class="note">
	<p>There are a few things to be wary of when using pooled threads:</p>
	<p class="ch">使用池线程没有太多需要操心的事情：</p>
	<ul>
		<li>You cannot set the <code>Name</code> of a pooled thread, making
		  debugging more difficult (although you can attach a description when debugging
		  in Visual Studio’s Threads window).</li>
		<p class="ch">不能设置池线程的 <code>Name</code> 属性，这给调试带来了麻烦，但是在 Visual Studio
		  的线程窗口中可以给线程附加一个描述。</p>
		<li>Pooled threads are always <i><a href="#_Foreground_and_Background_Threads">background
		  threads</a></i> (this is usually not a problem).</li>
		<p class="ch">池线程永远是<i><a href="#_Foreground_and_Background_Threads">后台线程</a></i>，这不是一个bug。</p>
		<li><a href="part2.html#_Blocking">Blocking</a> a pooled thread may trigger additional latency
		  in the early life of an application unless you call <code>ThreadPool.SetMinThreads</code>
		  (see <a href="#_Optimizing_the_Thread_Pool">Optimizing the Thread Pool</a>).</li>
		<p class="ch"><a href="part2.html#_Blocking">阻塞</a>一个池线程可能会在应用程序生命周期的早期产生一些负面影响，除非你调用
		  <code>ThreadPool.SetMinThreads</code> 方法（见<a href="#_Optimizing_the_Thread_Pool">线程池优化</a>）。</p>
	</ul>
	<p>You are free to change the <a href="#_Thread_Priority">priority</a>
	  of a pooled thread — it will be restored to normal when released back to the pool.</p>
	<p class="ch">你可以随意改变池线程的<a href="#_Thread_Priority">优先级</a>，返回线程池后它会自动恢复正常的优先级。</p>
</div>

<p>You can query if you’re currently executing on a pooled
thread via the property <code>Thread.CurrentThread.IsThreadPoolThread</code>.</p>
<p class="ch">根据 <code>Thread.CurrentThread.IsThreadPoolThread</code> 属性可以判断当前线程是否为池线程。</p>
<h2>
	<a name="_Entering_the_Thread_Pool_via_TPL">Entering the Thread Pool via TPL | 通过任务并行库(TPL)访问线程池</a>
</h2>

<p>You can enter the thread pool easily using the <code><a href="part5.html#_Task_Parallelism">Task</a></code> classes in the Task
Parallel Library. The <code>Task</code> classes were introduced
in Framework 4.0: if you’re familiar with the older constructs, consider the
nongeneric <code>Task</code> class a replacement for <code><a href="#_QueueUserWorkItem">ThreadPool.QueueUserWorkItem</a></code>,
and the generic <code>Task&lt;TResult&gt;</code> a replacement
for <a href="#_Asynchronous_delegates">asynchronous delegates</a>. The newer
constructs are faster, more convenient, and more flexible than the old.</p>
<p class="ch">通过任务并行库(TPL)中的 <code><a href="part5.html#_Task_Parallelism">Task</a></code> 类，你可以轻松地访问线程池。<code>Task</code>
类是从 4.0 版本引入的。如果对老版本方法熟悉的话，你可以将非泛型的 <code>Task</code> 类看作 <code><a href="#_QueueUserWorkItem">ThreadPool.QueueUserWorkItem</a></code>
的替代，非泛型的 <code>Task&lt;TResult&gt;</code> 类看作是<a href="#_Asynchronous_delegates">异步代理</a>机制的替代。</p>

<p>To use the nongeneric <code>Task</code>
class, call <code>Task.Factory.StartNew</code>, passing in a
delegate of the target method:</p>
<p class="ch">调用 <code>Task.Factory.StartNew</code> 方法，并传入一个目标方法的代理，即可使用非泛型的 <code>Task</code> 类。</p>

<pre class="sh_csharp">
static void Main()    // The Task class is in <b>System.Threading.Tasks</b> | Task 类在 <b>System.Threading.Tasks</b> 命名空间下
{
  Task.Factory.StartNew (Go);
}
 
static void Go()
{
  Console.WriteLine ("Hello from the thread pool!");
}
</pre>

<p>
	<code>Task.Factory.StartNew</code> returns a
<code>Task</code> object, which you can then use to monitor the
task — for instance, you can wait for it to complete by calling its <code><a href="part5.html#_Waiting_on_Tasks">Wait</a></code> method.</p>
<p class="ch"><code>Task.Factory.StartNew</code> 方法返回一个 <code>Task</code> 对象，你可以使用这个对象来管理任务，比方说，调用 <code><a href="part5.html#_Waiting_on_Tasks">Wait</a></code> 方法等待任务完成。</p>

<div class="note"><p>Any unhandled exceptions are conveniently rethrown onto the
host thread when you call a task's <code><a href="part5.html#_Waiting_on_Tasks">Wait method</a></code>.
(If you don’t call <code>Wait</code> and instead abandon the task, an
unhandled exception will shut down the process <a href="#_Exception_Handling">as
with an ordinary thread</a>.)</p>
<p class="ch">调用<code><a href="part5.html#_Waiting_on_Tasks">Wait</a></code> 方法后，未被处理的异常会再次抛出，让宿主线程来处理。没有调用
<code>Wait</code> 方法，则未处理的异常会跟没有发生异常一样，结束进程。</p>
</div>

<p>The generic <code>Task&lt;TResult&gt;</code>
class is a subclass of the nongeneric <code>Task</code>. It lets
you get a return value back from the task after it finishes executing. In the
following example, we download a web page using <code>Task&lt;TResult&gt;</code>:</p>
<p class="ch">泛型类 <code>Task&lt;TResult&gt;</code> 是 <code>Task</code> 类的子类，在任务执行完成后它会返回一个值。下面这个示例，我们使用
<code>Task&lt;TResult&gt;</code> 下载一个网页：</p>

<pre class="sh_csharp">
static void Main()
{
  // Start the task executing:
  // 开始执行任务：
  Task&lt;string&gt; task = Task.Factory.StartNew<b>&lt;string&gt;</b>
    ( () =&gt; DownloadString ("http://www.linqpad.net") );
 
  // We can do other work here and it will execute in parallel:
  // 在这里我们可以并行地处理其他事情：
  RunSomeOtherMethod();
 
  // When we need the task's return value, we query its Result property:
  // If it's still executing, the current thread will now block (wait)
  // until the task finishes:
  // 需要任务的返回值的话，我们可以检查 Result 属性：
  // 如果任务还在执行中，则当前线程被阻塞(wait)，只到任务执行完成。
  string result = <b>task.Result</b>;
}
 
static string DownloadString (string uri)
{
  using (var wc = new System.Net.WebClient())
    return wc.DownloadString (uri);
}
</pre>

<p>(The <code>&lt;string&gt;</code> type
argument highlighted is for clarity: it would be <em>inferred</em> if we
omitted it.)</p>
<p class="ch">（高亮显示类型参数 <code>&lt;string&gt;</code> 是出于清晰考虑，也可以省略掉类型参数。）</p>

<p>Any unhandled exceptions are automatically rethrown when
you query the task's <code>Result</code> property, wrapped in an <code><a href="part5.html#_Working_with_AggregateException">AggregateException</a></code>.
However, if you fail to query its <code>Result</code> property
(and don’t call <code>Wait</code>) any unhandled exception will
take the process down. </p>
<p class="ch">查询任务的 <code>Result</code> 属性时，未被处理的异常会包装成 <code>AggregateException</code> 后重新抛出。如果没有调用 <code>Wait</code>
方法，而查询 <code>Result</code> 属性失败，则未处理的异常会导致进程退出。</p>

<p>The Task Parallel Library has many more features, and is
particularly well suited to leveraging multicore processors. We’ll resume our
discussion of TPL <a href="part5.html#_Task_Parallelism">in Part 5</a>. </p>
<p class="ch">任务并行库(TPL)具有很多功能，特别适合于处理多核处理器架构下的多线程问题，我们将会在 <a href="part5.html#_Task_Parallelism">第 5 部分</a> 继续讨论这个话题。</p>

<h2>
	<a name="_Entering_the_Thread_Pool_Without_TPL">Entering the Thread Pool Without TPL | 不通过任务并行库(TPL)访问线程池</a>
</h2>

<p>You can't use the Task Parallel Library if you're
targeting an earlier version of the .NET Framework (prior to 4.0). Instead, you
must use one of the older constructs for entering the thread pool: <code>ThreadPool.QueueUserWorkItem</code> and asynchronous delegates.
The difference between the two is that asynchronous delegates let you return
data from the thread. Asynchronous delegates also marshal any exception back to
the caller.</p>
<p class="ch">如果程序基于 4.0 之前的 .NET 框架开发，你将无法使用 TPL 库。好在有一个替代的方法：<code>ThreadPool.QueueUserWorkItem</code>方法和异步代理机制。</p>

<h3>
	<a name="_QueueUserWorkItem">QueueUserWorkItem</a>
</h3>

<p>To use <code>QueueUserWorkItem</code>,
simply call this method with a delegate that you want to run on a pooled
thread: </p>
<p class="ch"><code>QueueUserWorkItem</code> 方法的用法很简单，传入一个想在池线程上运行的代理即可：</p>

<pre class="sh_csharp">
static void Main()
{
  ThreadPool.QueueUserWorkItem (Go);
  ThreadPool.QueueUserWorkItem (Go, 123);
  Console.ReadLine();
}
 
static void Go (object data)   // <i>data</i> will be <b>null</b> with the first call. | 第一次调用中，<i>data</i> 为 <b>null</b>
{
  Console.WriteLine ("Hello from the thread pool! " + data);
}
</pre>

<pre class="output">
Hello from the thread pool!
Hello from the thread pool! 123
</pre>

<p>Our target method, <code>Go</code>, must
accept a single <code>object</code> argument (to satisfy the <code>WaitCallback</code> delegate). This provides a convenient way of
passing data to the method, just like with <code>ParameterizedThreadStart</code>.
Unlike with <code>Task</code>, <code>QueueUserWorkItem</code>
doesn't return an object to help you subsequently manage execution. Also, you
must explicitly deal with exceptions in the target code — unhandled exceptions
will <a href="#_Exception_Handling">take down the program</a>.</p>
<p class="ch">目标方法 <code>Go</code> 必须带一个 <code>object</code> 类型的参数（为了适配 <code>WaitCallback</code> 代理），这是一种与 <code>ParameterizedThreadStart</code>
类似的向线程方法传递数据的简单做法。不同于 <code>Task</code> 类，<code>QueueUserWorkItem</code> 方法并不返回数据帮你管理任务的后续执行情况。必须手动处理异常——不处理异常的后果就是宕机。</p>

<h3>
	<a name="_Asynchronous_delegates">Asynchronous delegates | 异步代理</a>
</h3>

<p>
	<code>ThreadPool.QueueUserWorkItem</code>
doesn’t provide an easy mechanism for getting return values back from a thread
after it has finished executing. Asynchronous delegate invocations
(asynchronous delegates for short) solve this, allowing any number of typed
arguments to be passed in both directions. Furthermore, unhandled exceptions on
asynchronous delegates are conveniently rethrown on the original thread (or
more accurately, the thread that calls <code>EndInvoke</code>),
and so they don’t need explicit handling.</p>
<p class="ch">使用 <code>ThreadPool.QueueUserWorkItem</code> 实现线程结束后返回数据并不是件容易的事。异步代理调用（或者说异步代理）可以解决这个问题，实现任意数目任意类型参数的双方传递。更重要的是，异步代理内的未处理异常只会抛给原线程（准确说来，是调用
<code>EndInvoke</code> 方法的线程）。</p>

<div class="warning"><p>Don’t confuse asynchronous delegates with asynchronous
methods (methods starting with <em>Begin</em> or <em>End</em>, such as <code>File.BeginRead</code>/<code>File.EndRead</code>).
Asynchronous methods follow a similar protocol outwardly, but they exist to
solve a much harder problem, which we describe in Chapter 23 of <a href="http://www.albahari.com/nutshell/">C# 4.0 in a Nutshell</a>.</p>
<p class="ch">不要混淆了异步代理和异步方法（以 <em>Begin</em> 或 <em>End</em> 开头的方法，像 <code>File.BeginRead</code>/<code>File.EndRead</code> 等）。异步方法是为了解决一个麻烦得多的问题，虽然从表面上看跟异步代理差不多，这一点我们将在
<a href="http://www.albahari.com/nutshell/">言简意赅话 C# 4.0</a> 一书的第 23 章中介绍。</p>
</div>
<p>Here’s how you start a worker task via an asynchronous
delegate:</p>
<p class="ch">使用异步代理启动工作任务的步骤如下：</p>

<ol>
	<li>Instantiate a delegate targeting the method you want to run in parallel
(typically one of the predefined <code>Func</code> delegates).</li>
	<li>Call <code>BeginInvoke</code> on the delegate, saving its <code>IAsyncResult</code> return value.<br /><br /><code>BeginInvoke</code> returns immediately to the caller. You can then perform other activities while the pooled thread is working.</li>
	<li>When you need the results, call <code>EndInvoke</code> on
the delegate, passing in the saved <code>IAsyncResult</code>
object.</li>
</ol>

<ol class="ch">
  <li>实例化一个指向你想并行执行的方法的代理对象，通常是 <code>Func</code> 代理；</li>
  <li>调用代理的 <code>BeginInvoke</code> 方法，保存 <code>IAsyncResult</code> 的返回值，<br/>
    <code>BeginInvoke</code> 方法很快就执行完成，你可以在池线程工作的状态下完成其他工作；
  </li>
  <li>如果想知道结果，将之前保存的 <code>IAsyncResult</code> 对象传递给 <code>EndInvoke</code> 方法。</li>
</ol>

<p>In the following example, we use an asynchronous delegate
invocation to execute concurrently with the main thread, a simple method that
returns a string’s length:</p>
<p class="ch">下面，我们用异步代理调用的方法实现工作线程与主线程并行地执行一段代码——简单地返回字符串的长度：</p>

<pre class="sh_csharp">
static void Main()
{
  Func&lt;string, int&gt; method = Work;
  IAsyncResult cookie = method.BeginInvoke ("test", null, null);
  //
  // ... here's where we can do other work in parallel...
  // 在这里，你可以平行地做其他事情
  //
  int result = method.EndInvoke (cookie);
  Console.WriteLine ("String length is: " + result);
}
 
static int Work (string s) { return s.Length; }
</pre>

<p>
	<code>EndInvoke</code> does three things.
First, it waits for the asynchronous delegate to finish executing, if it hasn’t
already. Second, it receives the return value (as well as any <code>ref</code> or <code>out</code> parameters). Third,
it throws any unhandled worker exception back to the calling thread.</p>
<p class="ch"><code>EndInvoke</code> 做三件事：1、异步代理没有执行完成的话，等待其结束；2、接收返回值（类似于 <code>ref</code> 或 <code>out</code> 参数）；3、将未处理异常抛给调用线程。</p>

<div class="warning"><p>If the method you’re calling with an asynchronous
delegate has no return value, you are still (technically) obliged to call <code>EndInvoke</code>. In practice, this is open to debate; there are
no <code>EndInvoke</code> police to administer punishment to
noncompliers! If you choose not to call <code>EndInvoke</code>,
however, you’ll need to consider exception handling on the worker method to
avoid silent failures.</p>
<p class="ch">技术上说，使用异步代理调用一个没有返回值的方法时，仍然要求调用 <code>EndInvoke</code> 方法。实际使用中，这一要求值得商榷。说白了，世界上也不存在一种警察来监督你、要求你必须使用 <code>EndInvoke</code>。然而，如果你选择不使用，你就要考虑一下工作方法中的异常处理了。</p>
</div>

<p>You can also specify a callback delegate when calling <code>BeginInvoke</code> — a method accepting an <code>IAsyncResult</code>
object that’s automatically called upon completion. This allows the instigating
thread to “forget” about the asynchronous delegate, but it requires a bit of
extra work at the callback end:</p>
<p class="ch">你还可以给 <code>BeginInvoke</code> 指定一个回调代理，这个回调代理在工作代理完成后立刻接收 <code>IAsyncResult</code> 对象，开始执行，主调线程好像“忘记”了异步代理。只不过在回调代理结束前需要一点点额外的处理：</p>

<pre class="sh_csharp">
static void Main()
{
  Func&lt;string, int&gt; method = Work;
  method.BeginInvoke ("test", Done, method);
  // ...
  //
}
 
static int Work (string s) { return s.Length; }
 
static void Done (IAsyncResult cookie)
{
  var target = (Func&lt;string, int&gt;) cookie.AsyncState;
  int result = target.EndInvoke (cookie);
  Console.WriteLine ("String length is: " + result);
}
</pre>

<p>The final argument to <code>BeginInvoke</code>
is a user state object that populates the <code>AsyncState</code>
property of <code>IAsyncResult</code>. It can contain anything
you like; in this case, we’re using it to pass the <code>method</code>
delegate to the completion callback, so we can call <code>EndInvoke</code>
on it.</p>
<p class="ch"><code>BeginInvoke</code> 方法的最后一个参数是一个用户状态对象，它保存在 <code>IAsyncResult</code> 的 <code>AsyncState</code>
属性之中。这个参数可以包含任意数据。在上面这个示例中，我们将代理 <code>method</code> 传递给回调函数，在回调函数中我们就可以使用这个代理了。</p>

<h2>
	<a name="_Optimizing_the_Thread_Pool">Optimizing the Thread Pool | 优化线程池</a>
</h2>

<p>The thread pool starts out with one thread in its pool. As
tasks are assigned, the pool manager “injects” new threads to cope with the
extra concurrent workload, up to a maximum limit. After a sufficient period of
inactivity, the pool manager may “retire” threads if it suspects that doing so
will lead to better throughput.</p>

<p>You can set the upper limit of threads that the pool will
create by calling <code>ThreadPool.SetMaxThreads</code>; the
defaults are:</p>

<ul>
	<li>1023 in Framework 4.0 in a 32-bit environment</li>
	<li>32768 in Framework 4.0 in a 64-bit environment</li>
	<li>250 per core in Framework 3.5</li>
	<li>25 per core in Framework 2.0</li>
</ul>

<p>(These figures may vary according to the hardware and
operating system.) The reason there are that many is to ensure progress should
some threads be <a href="part2.html#_Blocking">blocked</a> (idling while awaiting some
condition, such as a response from a remote computer).</p>

<p>You can also set a lower limit by calling <code>ThreadPool.SetMinThreads</code>. The role of the lower limit is
subtler: it’s an advanced optimization technique that instructs the pool
manager not to <em>delay</em> in the allocation of threads until reaching the
lower limit. Raising the minimum thread count improves concurrency when there
are <a href="part2.html#_Blocking">blocked</a> threads (see sidebar).</p>

<p class="note">The default lower limit is one thread per processor core — the
minimum that allows full CPU utilization. On server environments, though (such
ASP.NET under IIS), the lower limit is typically much higher — as much as 50 or
more.</p>

<div class="sidebar">
<p class="sidebartitle">How Does the Minimum Thread Count Work? | 最小线程计数是如何工作的？</p>

<p>Increasing the thread pool’s minimum thread count to <em>x</em>
doesn’t actually force <em>x</em> threads to be created right away — threads are
created only on demand. Rather, it instructs the pool manager to create up to <em>x</em>
threads the <em>instant</em> they are required. The question, then, is why
would the thread pool otherwise delay in creating a thread when it’s needed? </p>

<p>The answer is to prevent a brief burst of short-lived
activity from causing a full allocation of threads, suddenly swelling an
application’s memory footprint. To illustrate, consider a quad-core computer
running a client application that enqueues 40 tasks at once. If each task
performs a 10 ms calculation, the whole thing will be over in 100 ms, assuming
the work is divided among the four cores. Ideally, we’d want the 40 tasks to
run on <em>exactly four threads</em>:</p>

<ul>
	<li>Any less and we’d not be making maximum use of all four cores.</li>
	<li>Any more and we’d be wasting memory and CPU time creating
unnecessary threads.</li>
</ul>

<p>And this is exactly how the thread pool works. Matching
the thread count to the core count allows a program to retain a small memory
footprint without hurting performance — as long as the threads are efficiently
used (which in this case they are).</p>

<p>But now suppose that instead of working for 10 ms, each
task queries the Internet, waiting half a second for a response while the local
CPU is idle. The pool manager’s thread-economy strategy breaks down; it would
now do better to create more threads, so all the Internet queries could happen
simultaneously.</p>

<p>Fortunately, the pool manager has a backup plan. If its
queue remains stationary for more than half a second, it responds by creating
more threads — one every half-second — up to the capacity of the thread pool.</p>

<p>The half-second delay is a two-edged sword. On the one
hand, it means that a one-off burst of brief activity doesn’t make a program
suddenly consume an extra unnecessary 40 MB (or more) of memory. On the other
hand, it can needlessly delay things when a pooled thread blocks, such as when
querying a database or calling <code>WebClient.DownloadFile</code>.
For this reason, you can tell the pool manager not to delay in the allocation
of the first <em>x</em> threads, by calling <code>SetMinThreads</code>,
for instance:</p>

<pre class="sh_csharp">
ThreadPool.SetMinThreads (50, 50);
</pre>

<p>(The second value indicates how many threads to assign to
I/O completion ports, which are used by the APM, described in Chapter 23 of <a href="http://www.albahari.com/nutshell/">C# 4.0 in a Nutshell</a>.)</p>

<p>The default value is one thread per core.</p>

</div>

<p><a href="part2.html">Part 2 &gt;&gt;</a></p>
</div>
</body>
</html>