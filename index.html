<!DOCTYPE html>
<html>
<meta charset="utf-8"/>
<head>
<title>C#中的线程</title>
<link rel="stylesheet" type="text/css" href="./css/tstyles.css">
<link rel="stylesheet" type="text/css" media="print" href="./css/print.css">
<link type="text/css" rel="stylesheet" href="./css/sh_style.css">
<script type="text/javascript" src="./scripts/sh_main.min.js"></script>
<script type="text/javascript" src="./scripts/sh_csharp.js"></script>
<style type="text/css"></style>
</head>
<body onload="sh_highlightDocument();">
<div id="main">
  <p class="title">C#中的线程</p>
  <p class="author">作者：Joseph Albahari</p>
  <p class="author">翻译：chuwentao</p>
  <div id="ctl00_toc">
  <table class="toc" border="0" cellspacing="0" cellpadding="0">
	<tbody><tr>
	  <th class="tocactive">Part 1</th>
	  <th class="toc"><a class="toc" href="part2.html"> Part 2</a></th>
	  <th class="toc"><a class="toc" href="part3.html"> Part 3</a></th>
	  <th class="toc"><a class="toc" href="part4.html"> Part 4</a></th>
	  <th class="toc"><a class="toc" href="part5.html"> Part 5</a></th>
	</tr><tr>
	  <td class="tocactive">入门</td>
	  <td class="toc"><a class="toc" href="part2.html">线程同步基础</a></td>
	  <td class="toc"><a class="toc" href="part3.html">使用多线程</a></td>
	  <td class="toc"><a class="toc" href="part4.html">高级话题</a></td>
	  <td class="toc"><a class="toc" href="part5.html">平行编程</a></td>
	</tr></tbody>
  </table>
  <p class="sectiontitle">Part 1: 入门</p>
  <h1><a name="_Introduction">概述及概念</a></h1>
  <p>C# supports parallel execution of code through multithreading. A thread is an independent 
execution path, able to run simultaneously with other threads.</p>
  <p>C#支持通过多线程来并行地执行代码。一个线程是一条独立的执行路径，它可以与其他线程同时运行。</p>
  <p>A C# <em>client</em> program (Console, WPF, or Windows
Forms) starts in a single thread created automatically by the CLR and operating
system (the “main” thread), and is made multithreaded by creating additional
threads. Here’s a simple example and its output:</p>
  <p>一个C#<em>客户端程序</em>(Console, WPF, or Windows Forms)从一个CLR或操作系统创建的线程(主线程)启动，
  创建其他更多线程后就是一个多线程程序。下面是一个示例及其输出：</p>
<div class="note">
	<p>All examples assume the following namespaces are imported:</p>
	<p>所有示例假定引入以下命名空间：</p>
	<pre>using System;
using System.Threading;</pre>

</div>

<pre class="sh_csharp">
class ThreadTest
{
  static void Main()
  {
    Thread t = new Thread (WriteY);          // Kick off a new thread | 创建一个新线程
    t.Start();                               // running WriteY() | 开始运行WriteY()
 
    // Simultaneously, do something on the main thread.
    // 同时，在主线程中也做同样的事情。
    for (int i = 0; i &lt; 1000; i++) Console.Write ("x");
  }
 
  static void WriteY()
  {
    for (int i = 0; i &lt; 1000; i++) Console.Write ("y");
  }
}
</pre>

<pre class="output">
xxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyy
yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxx
xxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy
yyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
...
</pre>

<p>The main thread creates a new thread <code>t</code>
on which it runs a method that repeatedly prints the character “y”.
Simultaneously, the main thread repeatedly prints the character “x”:</p>
<p>主线程创建了一个新的线程 <code>t</code>，线程 <code>t</code> 重复地打印字符’y’；
同时，主线程重复地打印字符’x’。下面是输出：</p>
<div class="figure">
	<img width="700" height="179" src="./resources/NewThread.png" alt="Starting a new Thread" />
</div>

<p>Once started, a thread’s <code>IsAlive</code>
property returns <code>true</code>, until the point where the
thread ends. A thread ends when the delegate passed to the <code>Thread</code>’s
constructor finishes executing. Once ended, a thread cannot restart.</p>
<p>线程启动后，它的 <code>IsAlive</code> 属性就为 <code>true</code>，直到线程终止。线
程构造时传入的代理运行完成后，线程就自动终止。线程终止后无法再次启动。</p>
<p>The CLR assigns each thread its own memory stack so that
local variables are kept separate. In the next example, we define a method with
a local variable, then call the method simultaneously on the main thread and a
newly created thread:</p>

<pre class="sh_csharp">
static void Main() 
{
  new Thread (Go).Start();      // Call Go() on a new thread
  Go();                         // Call Go() on the main thread
}
 
static void Go()
{
  // Declare and use a local variable - 'cycles'
  for (int cycles = 0; cycles &lt; 5; cycles++) Console.Write ('?');
}
</pre>

<pre class="output">
??????????
</pre>

<p>A separate copy of the cycles variable is created on each
thread's memory stack, and so the output is, predictably, ten question marks.</p>

<p>Threads share data if they have a common reference to the
same object instance. For example:</p>

<pre class="sh_csharp">
class ThreadTest
{
  bool done;
 
  static void Main()
  {
    ThreadTest tt = new ThreadTest();   // Create a common instance
    new Thread (tt.Go).Start();
    tt.Go();
  }
 
  // Note that Go is now an instance method
  void Go() 
  {
     if (!done) { done = true; Console.WriteLine ("Done"); }
  }
}
</pre>

<p>Because both threads call <code>Go()</code>
on the same <code>ThreadTest</code> instance, they share the <code>done</code> field. This results in "Done" being printed
once instead of twice:</p>

<pre class="output">
Done
</pre>

<p>Static fields offer another way to share data between
threads. Here’s the same example with <code>done</code> as a
static field:</p>

<pre class="sh_csharp">
class ThreadTest 
{
  static bool done;    // Static fields are shared between all threads
 
  static void Main()
  {
    new Thread (Go).Start();
    Go();
  }
 
  static void Go()
  {
    if (!done) { done = true; Console.WriteLine ("Done"); }
  }
}
</pre>

<p>Both of these examples illustrate another key concept:
that of <a href="part2.aspx#_Thread_Safety">thread safety</a> (or rather, lack of it!)
The output is actually indeterminate: it’s possible (though unlikely) that “Done”
could be printed twice. If, however, we swap the order of statements in the <code>Go</code> method, the odds of “Done” being printed twice go up
dramatically:</p>

<pre class="sh_csharp">
static void Go()
{
  if (!done) { Console.WriteLine ("Done"); done = true; }
}
</pre>

<pre class="output">Done
Done   <i>(usually!)</i></pre>

<p>The problem is that one thread can be evaluating the <code>if</code> statement right as the other thread is executing the <code>WriteLine</code> statement — before it’s had a chance to set <code>done</code> to true.</p>

<p>The remedy is to obtain an <a href="part2.aspx#_Locking">exclusive
lock</a> while reading and writing to the common field. C# provides the <a href="part2.aspx#_Locking">lock</a> statement for just this purpose:</p>

<pre class="sh_csharp">
class ThreadSafe 
{
  static bool done;
  static readonly object locker = new object();
 
  static void Main()
  {
    new Thread (Go).Start();
    Go();
  }
 
  static void Go()
  {
    lock (locker)
    {
      if (!done) { Console.WriteLine ("Done"); done = true; }
    }
  }
}
</pre>

<p>When two threads simultaneously contend a lock (in this
case, <code>locker</code>), one thread waits, or <a href="part2.aspx#_Blocking">blocks</a>, until the lock becomes available. In this case,
it ensures only one thread can enter the critical section of code at a time,
and “Done” will be printed just once. Code that's protected in such a manner — from
indeterminacy in a multithreading context — is called <a href="part2.aspx#_Thread_Safety">thread-safe</a>.</p>

<p class="warning">Shared data is the primary cause of complexity and
obscure errors in multithreading. Although often essential, it pays to keep it
as simple as possible. </p>

<p>A thread, while <i>blocked</i>,
doesn't consume CPU resources.</p>

<h2>
	<a name="_Join_and_Sleep">Join and Sleep</a>
</h2>

<p>You can wait for another thread to end by calling its <code>Join</code> method. For example:</p>

<pre class="sh_csharp">
static void Main()
{
  Thread t = new Thread (Go);
  t.Start();
  t.Join();
  Console.WriteLine ("Thread t has ended!");
}
 
static void Go()
{
  for (int i = 0; i &lt; 1000; i++) Console.Write ("y");
}
</pre>

<p>This prints “y” 1,000 times, followed by “Thread t has
ended!” immediately afterward. You can include a timeout when calling <code>Join</code>, either in milliseconds or as a <code>TimeSpan</code>.
It then returns <code>true</code> if the thread ended or <code>false</code> if it timed out.</p>

<p>
	<code><a name="_Sleep_And_Yield">Thread.Sleep</a></code> pauses the current
thread for a specified period:</p>

<pre class="sh_csharp">
Thread.Sleep (TimeSpan.FromHours (1));  // sleep for 1 hour
Thread.Sleep (500);                     // sleep for 500 milliseconds
</pre>

<p>While waiting on a <code>Sleep</code> or <code>Join</code>, a thread is <i><a href="part2.aspx#_Blocking">blocked</a></i> and
so does not consume CPU resources.</p>

<div class="note">
	<p>
		<code>Thread.Sleep(0)</code> relinquishes the
thread’s current time slice immediately, voluntarily handing over the CPU to
other threads. Framework 4.0’s new <code>Thread.Yield()</code>
method does the same thing — except that it relinquishes only to threads running
on the <em>same</em> processor.</p>
	<p>
		<code>Sleep(0)</code> or <code>Yield</code>
is occasionally useful in production code for advanced performance tweaks. It’s
also an excellent diagnostic tool for helping to uncover <a href="part2.aspx#_Thread_Safety">thread safety</a> issues: if inserting <code>Thread.Yield()</code> anywhere in your code makes or breaks the
program, you almost certainly have a bug.</p>
</div>

<h2>
	<a name="_How_Threading_Works">How Threading Works</a>
</h2>

<div class="linqpad">
	<p style="margin:3pt; font-size:150%; font-weight:bold; color:#A57">Kiss goodbye to SQL Management Studio</p>
	<p>
		<a href="http://www.linqpad.net/">
		<img border="0" src="linqpadlogo.png" alt="LINQPad" width="259" height="249" /></a>
	</p>
	<p style="margin:0; font-size:270%; font-weight:bold; color:#A57">LINQPad</p>
	<p style="margin:3pt; font-size:170%; font-weight:bold; color:teal">FREE</p>
	<p style="font-size:110%">Query databases in a<br /><a href="http://www.linqpad.net">modern query language</a></p>
	<p>Written by the author of this article</p>
</div>

<p>Multithreading is managed internally by a thread
scheduler, a function the CLR typically delegates to the operating system. A
thread scheduler ensures all active threads are allocated appropriate execution
time, and that threads that are waiting or blocked (for instance, on an
exclusive lock or on user input)  do not consume CPU time.</p>

<p>On a single-processor computer, a thread scheduler
performs <i>time-slicing</i> — rapidly switching
execution between each of the active threads. Under Windows, a time-slice is
typically in the tens-of-milliseconds region — much larger than the CPU overhead
in actually switching context between one thread and another (which is
typically in the few-microseconds region).</p>

<p>On a multi-processor computer, multithreading is
implemented with a mixture of time-slicing and genuine concurrency, where
different threads run code simultaneously on different CPUs. It’s almost
certain there will still be some time-slicing, because of the operating system’s
need to service its own threads — as well as those of other applications.</p>

<p>A thread is said to be <i>preempted</i>
when its execution is interrupted due to an external factor such as
time-slicing. In most situations, a thread has no control over when and where
it’s preempted.</p>

<h2>
	<a name="_Threads_vs_Processes">Threads vs Processes</a>
</h2>

<p>A thread is analogous to the operating system process in
which your application runs. Just as processes run in parallel on a computer,
threads run in parallel <em>within a single process</em>. Processes are fully
isolated from each other; threads have just a limited degree of isolation. In
particular, threads share (heap) memory with other threads running in the same
application. This, in part, is why threading is useful: one thread can fetch
data in the background, for instance, while another thread can display the data
as it arrives.</p>

<h2>
	<a name="_Threadings_Uses_and_Misuses">Threading’s Uses and Misuses</a>
</h2>

<p>Multithreading has many uses; here are the most common:</p>

<dl>
	<dt>Maintaining a responsive user interface</dt>
	<dd>By running time-consuming tasks on a parallel “worker”
thread, the main UI thread is free to continue processing keyboard and mouse
events.</dd>
	<dt>Making efficient use of an otherwise blocked CPU</dt>
	<dd>Multithreading is useful when a thread is awaiting a
response from another computer or piece of hardware. While one thread is
blocked while performing the task, other threads can take advantage of the
otherwise unburdened computer.</dd>
	<dt>Parallel programming</dt>
	<dd>Code that performs intensive calculations can execute
faster on multicore or multiprocessor computers if the workload is shared among
multiple threads in a “divide-and-conquer” strategy (see <a href="part5.aspx">Part 5</a>).</dd>
	<dt>Speculative execution</dt>
	<dd>On multicore machines, you can sometimes improve
performance by predicting something that might need to be done, and then doing
it ahead of time. <a href="http://www.linqpad.net/">LINQPad</a> uses this
technique to speed up the creation of new queries. A variation is to run a
number of different algorithms in parallel that all solve the same task.
Whichever one finishes first “wins” — this is effective when you can’t know ahead
of time which algorithm will execute fastest.</dd>
	<dt>Allowing requests to be processed simultaneously</dt>
	<dd>On a server, client requests can arrive concurrently and
so need to be handled in parallel (the .NET Framework creates threads for this
automatically if you use ASP.NET, WCF, Web Services, or Remoting). This can
also be useful on a client (e.g., handling peer-to-peer networking — or even
multiple requests from the user).</dd>
</dl>

<p>With technologies such as ASP.NET and WCF, you may be <a href="part2.aspx#_Thread_Safety_in_Application_Servers">unaware that multithreading is even taking place</a> — unless
you access shared data (perhaps via static fields) without appropriate <a href="part2.aspx#_Locking">locking</a>, <a href="part2.aspx#_Thread_Safety_in_Application_Servers">running afoul of
thread safety.</a></p>

<p>Threads also come with strings attached. The biggest is
that multithreading can increase complexity. Having lots of threads does not in
and of itself create much complexity; it’s the interaction between threads
(typically via shared data) that does. This applies whether or not the
interaction is intentional, and can cause long development cycles and an
ongoing susceptibility to intermittent and nonreproducible bugs. For this
reason, it pays to keep interaction to a minimum, and to stick to simple and
proven designs wherever possible. This article focuses largely on dealing with
just these complexities; remove the interaction and there’s much less to say!</p>

<p class="note">A good strategy is to encapsulate multithreading logic into
reusable classes that can be independently examined and tested. The Framework
itself offers many higher-level threading constructs, which we cover later. </p>

<p>Threading also incurs a resource and CPU cost in
scheduling and switching threads (when there are more active threads than CPU
cores) — and there’s also a creation/tear-down cost. Multithreading will not
always speed up your application — it can even slow it down if used excessively
or inappropriately. For example, when heavy disk I/O is involved, it can be
faster to have a couple of worker threads run tasks in sequence than to have 10
threads executing at once. (In <a href="part4.aspx#_Signaling_with_Wait_and_Pulse">Signaling with
Wait and Pulse</a>, we describe how to implement a <a href="part4.aspx#_Wait_Pulse_Producer_Consumer_Queue">producer/consumer queue</a>, which provides
just this functionality.)</p>

<h1>
	<a name="_Creating_and_Starting_Threads">Creating and Starting Threads</a>
</h1>

<p>As we saw in the introduction, threads are created using
the <code>Thread</code> class’s constructor, passing in a <code>ThreadStart</code> delegate which indicates where execution
should begin.  Here’s how the <code>ThreadStart</code> delegate
is defined:</p>

<pre class="sh_csharp">
public delegate void ThreadStart();
</pre>

<p>Calling <code>Start</code> on the thread
then sets it running. The thread continues until its method returns, at which
point the thread ends. Here’s an example, using the expanded C# syntax for
creating a <code>TheadStart</code> delegate:</p>

<pre class="sh_csharp">
class ThreadTest
{
  static void Main() 
  {
    Thread t = new Thread (new ThreadStart (Go));
 
    t.Start();   // Run Go() on the new thread.
    Go();        // Simultaneously run Go() in the main thread.
  }
 
  static void Go()
  {
    Console.WriteLine ("hello!");
  }
}
</pre>

<p>In this example, thread <code>t</code>
executes <code>Go()</code> — at (much) the same time the main
thread calls <code>Go()</code>. The result is two near-instant
hellos.</p>

<p>A thread can be created more conveniently by specifying
just a method group — and allowing C# to infer the <code>ThreadStart</code>
delegate:</p>

<pre class="sh_csharp">
Thread t = new Thread (Go);    // No need to explicitly use ThreadStart
</pre>

<p>Another shortcut is to use a lambda expression or
anonymous method:</p>

<pre class="sh_csharp">
static void Main()
{
  Thread t = new Thread ( () =&gt; Console.WriteLine ("Hello!") );
  t.Start();
}
</pre>

<h2>
	<a name="_Passing_Data_to_a_Thread">Passing Data to a Thread</a>
</h2>

<p>The easiest way to pass arguments to a thread’s target
method is to execute a lambda expression that calls the method with the desired
arguments:</p>

<pre class="sh_csharp">
static void Main()
{
  Thread t = new Thread ( <b>() =&gt; Print ("Hello from t!")</b> );
  t.Start();
}
 
static void Print (string message) 
{
  Console.WriteLine (message);
}
</pre>

<p>With this approach, you can pass in any number of
arguments to the method. You can even wrap the entire implementation in a multi-statement
lambda:</p>

<pre class="sh_csharp">
new Thread (() =&gt;
{
  Console.WriteLine ("I'm running on another thread!");
  Console.WriteLine ("This is so easy!");
}).Start();
</pre>

<p>You can do the same thing almost as easily in C# 2.0 with
anonymous methods:</p>

<pre class="sh_csharp">
new Thread (<b>delegate()</b>
{
  ...
}).Start();
</pre>

<p>Another technique is to pass an argument into <code>Thread</code>’s <code>Start</code> method:</p>

<pre class="sh_csharp">
static void Main()
{
  Thread t = new Thread (Print);
  t.Start <b>("Hello from t!")</b>;
}
 
static void Print (object messageObj)
{
  string message = (string) messageObj;   // We need to cast here
  Console.WriteLine (message);
}
</pre>

<p>This works because <code>Thread</code>’s
constructor is overloaded to accept either of two delegates:</p>

<pre class="sh_csharp">
public delegate void ThreadStart();
public delegate void ParameterizedThreadStart (object obj);
</pre>

<p>The limitation of <code>ParameterizedThreadStart</code>
is that it accepts only one argument. And because it’s of type <code>object</code>, it usually needs to be cast.</p>

<h3>Lambda expressions and captured variables</h3>

<p>As we saw, a lambda expression is the most powerful way to
pass data to a thread. However, you must be careful about accidentally
modifying <em>captured variables</em> after starting the thread, because these
variables are shared. For instance, consider the following:</p>

<pre class="sh_csharp">
for (int i = 0; i &lt; 10; i++)
  new Thread (() =&gt; Console.Write (i)).Start();
</pre>

<p>The output is nondeterministic! Here’s a typical result:</p>

<pre class="output">
0223557799
</pre>

<p>The problem is that the <code>i</code>
variable refers to the <em>same</em> memory location throughout the loop’s
lifetime. Therefore, each thread calls <code>Console.Write</code>
on a variable whose value may change as it is running!</p>

<p class="note">This is analogous to the problem we describe in “Captured
Variables” in Chapter 8 of <a href="http://www.albahari.com/nutshell/">C# 4.0
in a Nutshell</a>. The problem is less about multithreading and more about C#'s
rules for capturing variables (which are somewhat undesirable in the case of <code>for</code> and <code>foreach</code> loops).</p>

<p> The solution is to use a temporary variable as follows:</p>

<pre class="sh_csharp">
for (int i = 0; i &lt; 10; i++)
{
  int temp = i;
  new Thread (() =&gt; Console.Write (temp)).Start();
}
</pre>

<p>Variable <code>temp</code> is now local to
each loop iteration. Therefore, each thread captures a different memory
location and there’s no problem. We can illustrate the problem in the earlier
code more simply with the following example:</p>

<pre class="sh_csharp">
string text = "t1";
Thread t1 = new Thread ( () =&gt; Console.WriteLine (text) );
 
text = "t2";
Thread t2 = new Thread ( () =&gt; Console.WriteLine (text) );
 
t1.Start();
t2.Start();
</pre>

<p>Because both lambda expressions capture the same <code>text</code> variable, <code>t2</code> is printed
twice:</p>

<pre class="output">
t2
t2
</pre>

<h2>
	<a name="_Naming_Threads">Naming Threads</a>
</h2>

<p>Each thread has a <code>Name</code> property
that you can set for the benefit of debugging. This is particularly useful in
Visual Studio, since the thread’s name is displayed in the Threads Window and
Debug Location toolbar. You can set a thread’s name just once; attempts to
change it later will throw an exception.</p>

<p>The static <code>Thread.CurrentThread</code>
property gives you the currently executing thread. In the following example, we
set the main thread’s name:</p>

<pre class="sh_csharp">
class ThreadNaming
{
  static void Main()
  {
    Thread.CurrentThread.Name = "main";
    Thread worker = new Thread (Go);
    worker.Name = "worker";
    worker.Start();
    Go();
  }
 
  static void Go()
  {
    Console.WriteLine ("Hello from " + Thread.CurrentThread.Name);
  }
}
</pre>

<h2>
	<a name="_Foreground_and_Background_Threads">Foreground and Background Threads</a>
</h2>

<p>By default, threads you create explicitly are <i>foreground threads</i>. Foreground threads keep the
application alive for as long as any one of them is running, whereas <i>background threads</i> do not. Once all foreground
threads finish, the application ends, and any background threads still running
abruptly terminate.</p>

<p class="note">A thread’s foreground/background status has no relation to its
priority or allocation of execution time.</p>

<p>You can query or change a thread’s background status using
its <code>IsBackground</code> property. Here’s an example:</p>

<pre class="sh_csharp">
class PriorityTest
{
  static void Main (string[] args)
  {
    Thread worker = new Thread ( () =&gt; Console.ReadLine() );
    if (args.Length &gt; 0) worker.IsBackground = true;
    worker.Start();
  }
}
</pre>
</div>
</body>
</html>